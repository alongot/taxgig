/**
 * Expense Service
 * Manages manual expense entries including mileage tracking
 *
 * Sprint 3 Implementation:
 * - CRUD operations for manual expenses
 * - Mileage tracking with IRS standard rate
 * - Receipt photo and OCR data storage
 * - Business vs personal expense flagging
 */

import { v4 as uuidv4 } from 'uuid';
import { query, getClient } from '../config/database';
import {
  ManualExpense,
  ManualExpenseCreateInput,
  ManualExpenseUpdateInput,
  IRS_MILEAGE_RATE_2026,
} from '../types';
import { NotFoundError, BadRequestError } from '../utils/errors';

// =============================================================================
// TYPES
// =============================================================================

export interface ExpenseFilters {
  start_date?: Date;
  end_date?: Date;
  category_id?: string;
  is_business?: boolean;
  is_mileage?: boolean;
  min_amount?: number;
  max_amount?: number;
  search?: string;
}

export interface ExpenseListResult {
  expenses: ManualExpenseWithCategory[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    total_pages: number;
  };
  summary: {
    total_amount: number;
    business_amount: number;
    mileage_amount: number;
    expense_count: number;
  };
}

export interface ManualExpenseWithCategory extends ManualExpense {
  category_code?: string;
  irs_line_number?: string;
  deduction_rate?: number;
}

export interface MileageExpenseInput {
  expense_date: Date;
  miles: number;
  start_location?: string;
  end_location?: string;
  business_purpose: string;
  notes?: string;
}

export interface ReceiptData {
  receipt_photo_url: string;
  receipt_thumbnail_url?: string;
  ocr_raw_text?: string;
  ocr_confidence?: number;
  ocr_extracted_data?: {
    merchant?: string;
    amount?: number;
    date?: string;
    line_items?: Array<{ description: string; amount: number }>;
  };
}

// =============================================================================
// EXPENSE SERVICE CLASS
// =============================================================================

export class ExpenseService {
  /**
   * Create a new manual expense
   */
  async createExpense(
    userId: string,
    input: ManualExpenseCreateInput
  ): Promise<ManualExpenseWithCategory> {
    const expenseId = uuidv4();
    const now = new Date();

    // Validate category exists if provided
    if (input.category_id) {
      const categoryCheck = await query(
        'SELECT category_id FROM expense_categories WHERE category_id = $1 AND is_active = TRUE',
        [input.category_id]
      );
      if (categoryCheck.rows.length === 0) {
        throw new BadRequestError('Invalid expense category');
      }
    }

    // Calculate amount for mileage expenses
    let amount = input.amount;
    let mileageRate = null;

    if (input.is_mileage && input.miles) {
      mileageRate = input.mileage_rate || IRS_MILEAGE_RATE_2026;
      amount = input.miles * mileageRate;
    }

    const result = await query(
      `INSERT INTO manual_expenses (
        manual_expense_id, user_id, expense_date, merchant, amount,
        category_id, category_name, is_business, business_percentage,
        notes, payment_method, receipt_photo_url, receipt_thumbnail_url,
        ocr_raw_text, ocr_confidence, ocr_extracted_data,
        is_mileage, miles, mileage_rate, start_location, end_location,
        created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
      )
      RETURNING *`,
      [
        expenseId,
        userId,
        input.expense_date,
        input.merchant,
        amount,
        input.category_id || null,
        input.category_name,
        input.is_business ?? true,
        input.business_percentage ?? 100,
        input.notes || null,
        input.payment_method || null,
        input.receipt_photo_url || null,
        null, // receipt_thumbnail_url - would be generated by image processing
        null, // ocr_raw_text
        input.ocr_confidence || null,
        null, // ocr_extracted_data
        input.is_mileage ?? false,
        input.miles || null,
        mileageRate,
        input.start_location || null,
        input.end_location || null,
        now,
        now,
      ]
    );

    return this.getExpenseById(userId, expenseId);
  }

  /**
   * Create a mileage expense entry
   */
  async createMileageExpense(
    userId: string,
    input: MileageExpenseInput
  ): Promise<ManualExpenseWithCategory> {
    // Get or find mileage category
    const categoryResult = await query(
      `SELECT category_id, category_name FROM expense_categories
       WHERE category_code = 'mileage' AND is_active = TRUE`
    );

    let categoryId = null;
    let categoryName = 'Mileage (standard rate)';

    if (categoryResult.rows.length > 0) {
      categoryId = categoryResult.rows[0].category_id;
      categoryName = categoryResult.rows[0].category_name;
    }

    const mileageRate = IRS_MILEAGE_RATE_2026;
    const amount = input.miles * mileageRate;

    // Create merchant description including purpose and locations
    let merchant = `Mileage: ${input.business_purpose}`;
    if (input.start_location && input.end_location) {
      merchant = `${input.start_location} to ${input.end_location} - ${input.business_purpose}`;
    }

    return this.createExpense(userId, {
      expense_date: input.expense_date,
      merchant,
      amount,
      category_id: categoryId,
      category_name: categoryName,
      is_business: true,
      business_percentage: 100,
      notes: input.notes,
      is_mileage: true,
      miles: input.miles,
      mileage_rate: mileageRate,
      start_location: input.start_location,
      end_location: input.end_location,
    });
  }

  /**
   * Get a single expense by ID
   */
  async getExpenseById(userId: string, expenseId: string): Promise<ManualExpenseWithCategory> {
    const result = await query(
      `SELECT
        me.*,
        ec.category_code,
        ec.irs_line_number,
        ec.deduction_rate
      FROM manual_expenses me
      LEFT JOIN expense_categories ec ON me.category_id = ec.category_id
      WHERE me.manual_expense_id = $1 AND me.user_id = $2`,
      [expenseId, userId]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError('Expense not found');
    }

    return this.mapToExpenseWithCategory(result.rows[0]);
  }

  /**
   * Get expenses for a user with filtering and pagination
   */
  async getExpenses(
    userId: string,
    filters: ExpenseFilters = {},
    page: number = 1,
    limit: number = 50
  ): Promise<ExpenseListResult> {
    const conditions: string[] = ['me.user_id = $1'];
    const params: unknown[] = [userId];
    let paramIndex = 2;

    // Apply filters
    if (filters.start_date) {
      conditions.push(`me.expense_date >= $${paramIndex}`);
      params.push(filters.start_date);
      paramIndex++;
    }

    if (filters.end_date) {
      conditions.push(`me.expense_date <= $${paramIndex}`);
      params.push(filters.end_date);
      paramIndex++;
    }

    if (filters.category_id) {
      conditions.push(`me.category_id = $${paramIndex}`);
      params.push(filters.category_id);
      paramIndex++;
    }

    if (filters.is_business !== undefined) {
      conditions.push(`me.is_business = $${paramIndex}`);
      params.push(filters.is_business);
      paramIndex++;
    }

    if (filters.is_mileage !== undefined) {
      conditions.push(`me.is_mileage = $${paramIndex}`);
      params.push(filters.is_mileage);
      paramIndex++;
    }

    if (filters.min_amount !== undefined) {
      conditions.push(`me.amount >= $${paramIndex}`);
      params.push(filters.min_amount);
      paramIndex++;
    }

    if (filters.max_amount !== undefined) {
      conditions.push(`me.amount <= $${paramIndex}`);
      params.push(filters.max_amount);
      paramIndex++;
    }

    if (filters.search) {
      conditions.push(`(
        me.merchant ILIKE $${paramIndex}
        OR me.notes ILIKE $${paramIndex}
        OR me.category_name ILIKE $${paramIndex}
      )`);
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    const whereClause = conditions.join(' AND ');

    // Get total count
    const countResult = await query(
      `SELECT COUNT(*) as total FROM manual_expenses me WHERE ${whereClause}`,
      params
    );
    const total = parseInt(countResult.rows[0].total, 10);

    // Get summary - apply both business_percentage AND category deduction_rate
    const summaryResult = await query(
      `SELECT
        COALESCE(SUM(me.amount), 0) as total_amount,
        COALESCE(SUM(
          CASE WHEN me.is_business = TRUE
          THEN me.amount * me.business_percentage / 100 * COALESCE(ec.deduction_rate, 100) / 100
          ELSE 0 END
        ), 0) as business_amount,
        COALESCE(SUM(CASE WHEN me.is_mileage = TRUE THEN me.amount ELSE 0 END), 0) as mileage_amount,
        COUNT(*) as expense_count
      FROM manual_expenses me
      LEFT JOIN expense_categories ec ON me.category_id = ec.category_id
      WHERE ${whereClause}`,
      params
    );

    // Get paginated expenses
    const offset = (page - 1) * limit;
    params.push(limit, offset);

    const expensesResult = await query(
      `SELECT
        me.*,
        ec.category_code,
        ec.irs_line_number,
        ec.deduction_rate
      FROM manual_expenses me
      LEFT JOIN expense_categories ec ON me.category_id = ec.category_id
      WHERE ${whereClause}
      ORDER BY me.expense_date DESC, me.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      params
    );

    const expenses = expensesResult.rows.map(row => this.mapToExpenseWithCategory(row));

    return {
      expenses,
      pagination: {
        page,
        limit,
        total,
        total_pages: Math.ceil(total / limit),
      },
      summary: {
        total_amount: parseFloat(summaryResult.rows[0].total_amount) || 0,
        business_amount: parseFloat(summaryResult.rows[0].business_amount) || 0,
        mileage_amount: parseFloat(summaryResult.rows[0].mileage_amount) || 0,
        expense_count: parseInt(summaryResult.rows[0].expense_count, 10) || 0,
      },
    };
  }

  /**
   * Update an expense
   */
  async updateExpense(
    userId: string,
    expenseId: string,
    updates: ManualExpenseUpdateInput
  ): Promise<ManualExpenseWithCategory> {
    // Verify expense exists and belongs to user
    await this.getExpenseById(userId, expenseId);

    const setClause: string[] = [];
    const values: unknown[] = [];
    let paramIndex = 1;

    if (updates.expense_date !== undefined) {
      setClause.push(`expense_date = $${paramIndex}`);
      values.push(updates.expense_date);
      paramIndex++;
    }

    if (updates.merchant !== undefined) {
      setClause.push(`merchant = $${paramIndex}`);
      values.push(updates.merchant);
      paramIndex++;
    }

    if (updates.amount !== undefined) {
      setClause.push(`amount = $${paramIndex}`);
      values.push(updates.amount);
      paramIndex++;
    }

    if (updates.category_id !== undefined) {
      // Validate category exists
      if (updates.category_id) {
        const categoryCheck = await query(
          'SELECT category_id FROM expense_categories WHERE category_id = $1 AND is_active = TRUE',
          [updates.category_id]
        );
        if (categoryCheck.rows.length === 0) {
          throw new BadRequestError('Invalid expense category');
        }
      }
      setClause.push(`category_id = $${paramIndex}`);
      values.push(updates.category_id);
      paramIndex++;
    }

    if (updates.category_name !== undefined) {
      setClause.push(`category_name = $${paramIndex}`);
      values.push(updates.category_name);
      paramIndex++;
    }

    if (updates.is_business !== undefined) {
      setClause.push(`is_business = $${paramIndex}`);
      values.push(updates.is_business);
      paramIndex++;
    }

    if (updates.business_percentage !== undefined) {
      setClause.push(`business_percentage = $${paramIndex}`);
      values.push(updates.business_percentage);
      paramIndex++;
    }

    if (updates.notes !== undefined) {
      setClause.push(`notes = $${paramIndex}`);
      values.push(updates.notes);
      paramIndex++;
    }

    if (updates.payment_method !== undefined) {
      setClause.push(`payment_method = $${paramIndex}`);
      values.push(updates.payment_method);
      paramIndex++;
    }

    if (updates.receipt_photo_url !== undefined) {
      setClause.push(`receipt_photo_url = $${paramIndex}`);
      values.push(updates.receipt_photo_url);
      paramIndex++;
    }

    if (setClause.length === 0) {
      return this.getExpenseById(userId, expenseId);
    }

    setClause.push(`updated_at = NOW()`);
    values.push(expenseId, userId);

    await query(
      `UPDATE manual_expenses SET ${setClause.join(', ')}
       WHERE manual_expense_id = $${paramIndex} AND user_id = $${paramIndex + 1}`,
      values
    );

    return this.getExpenseById(userId, expenseId);
  }

  /**
   * Delete an expense
   */
  async deleteExpense(userId: string, expenseId: string): Promise<void> {
    const result = await query(
      'DELETE FROM manual_expenses WHERE manual_expense_id = $1 AND user_id = $2',
      [expenseId, userId]
    );

    if (result.rowCount === 0) {
      throw new NotFoundError('Expense not found');
    }
  }

  /**
   * Add receipt data to an expense
   */
  async addReceiptData(
    userId: string,
    expenseId: string,
    receiptData: ReceiptData
  ): Promise<ManualExpenseWithCategory> {
    // Verify expense exists and belongs to user
    await this.getExpenseById(userId, expenseId);

    await query(
      `UPDATE manual_expenses SET
        receipt_photo_url = $1,
        receipt_thumbnail_url = $2,
        ocr_raw_text = $3,
        ocr_confidence = $4,
        ocr_extracted_data = $5,
        updated_at = NOW()
      WHERE manual_expense_id = $6 AND user_id = $7`,
      [
        receiptData.receipt_photo_url,
        receiptData.receipt_thumbnail_url || null,
        receiptData.ocr_raw_text || null,
        receiptData.ocr_confidence || null,
        receiptData.ocr_extracted_data ? JSON.stringify(receiptData.ocr_extracted_data) : null,
        expenseId,
        userId,
      ]
    );

    return this.getExpenseById(userId, expenseId);
  }

  /**
   * Create expense from OCR receipt data
   * Suggests expense details based on OCR extraction
   */
  async createExpenseFromReceipt(
    userId: string,
    receiptData: ReceiptData
  ): Promise<ManualExpenseWithCategory> {
    const extracted = receiptData.ocr_extracted_data || {};

    // Use extracted data or defaults
    const expenseDate = extracted.date ? new Date(extracted.date) : new Date();
    const merchant = extracted.merchant || 'Unknown Merchant';
    const amount = extracted.amount || 0;

    // Try to auto-categorize based on merchant name
    let categoryId = null;
    let categoryName = 'Other business expenses';

    // Simple keyword matching for category suggestion
    const merchantLower = merchant.toLowerCase();
    if (merchantLower.includes('gas') || merchantLower.includes('fuel') || merchantLower.includes('shell') || merchantLower.includes('chevron')) {
      const catResult = await query(
        `SELECT category_id, category_name FROM expense_categories
         WHERE category_code = 'car_truck' AND is_active = TRUE`
      );
      if (catResult.rows.length > 0) {
        categoryId = catResult.rows[0].category_id;
        categoryName = catResult.rows[0].category_name;
      }
    } else if (merchantLower.includes('office') || merchantLower.includes('staples') || merchantLower.includes('depot')) {
      const catResult = await query(
        `SELECT category_id, category_name FROM expense_categories
         WHERE category_code = 'office_expense' AND is_active = TRUE`
      );
      if (catResult.rows.length > 0) {
        categoryId = catResult.rows[0].category_id;
        categoryName = catResult.rows[0].category_name;
      }
    }

    return this.createExpense(userId, {
      expense_date: expenseDate,
      merchant,
      amount,
      category_id: categoryId,
      category_name: categoryName,
      is_business: true,
      receipt_photo_url: receiptData.receipt_photo_url,
      ocr_confidence: receiptData.ocr_confidence,
    });
  }

  /**
   * Get expense statistics for a date range
   */
  async getExpenseStats(
    userId: string,
    startDate: Date,
    endDate: Date
  ): Promise<{
    total_expenses: number;
    business_deductions: number;
    mileage_deductions: number;
    expense_count: number;
    mileage_count: number;
    total_miles: number;
    expenses_by_category: Record<string, number>;
    monthly_breakdown: Array<{ month: string; amount: number }>;
  }> {
    // Main stats - apply both business_percentage AND category deduction_rate for proper IRS deductions
    const statsResult = await query(
      `SELECT
        COALESCE(SUM(me.amount), 0) as total_expenses,
        COALESCE(SUM(
          CASE WHEN me.is_business = TRUE
          THEN me.amount * me.business_percentage / 100 * COALESCE(ec.deduction_rate, 100) / 100
          ELSE 0 END
        ), 0) as business_deductions,
        COALESCE(SUM(CASE WHEN me.is_mileage = TRUE THEN me.amount ELSE 0 END), 0) as mileage_deductions,
        COUNT(*) as expense_count,
        COUNT(CASE WHEN me.is_mileage = TRUE THEN 1 END) as mileage_count,
        COALESCE(SUM(me.miles), 0) as total_miles
      FROM manual_expenses me
      LEFT JOIN expense_categories ec ON me.category_id = ec.category_id
      WHERE me.user_id = $1
        AND me.expense_date >= $2
        AND me.expense_date <= $3`,
      [userId, startDate, endDate]
    );

    // Expenses by category - returns raw business amounts (business_percentage only)
    // Deduction rate is applied separately in reports for display purposes
    const categoryResult = await query(
      `SELECT
        COALESCE(ec.category_code, 'uncategorized') as category,
        SUM(me.amount * me.business_percentage / 100) as total
      FROM manual_expenses me
      LEFT JOIN expense_categories ec ON me.category_id = ec.category_id
      WHERE me.user_id = $1
        AND me.expense_date >= $2
        AND me.expense_date <= $3
        AND me.is_business = TRUE
      GROUP BY ec.category_code
      ORDER BY total DESC`,
      [userId, startDate, endDate]
    );

    // Monthly breakdown
    const monthlyResult = await query(
      `SELECT
        TO_CHAR(expense_date, 'YYYY-MM') as month,
        SUM(amount) as amount
      FROM manual_expenses
      WHERE user_id = $1
        AND expense_date >= $2
        AND expense_date <= $3
      GROUP BY TO_CHAR(expense_date, 'YYYY-MM')
      ORDER BY month`,
      [userId, startDate, endDate]
    );

    const expensesByCategory: Record<string, number> = {};
    for (const row of categoryResult.rows) {
      expensesByCategory[row.category] = parseFloat(row.total) || 0;
    }

    const stats = statsResult.rows[0];

    return {
      total_expenses: parseFloat(stats.total_expenses) || 0,
      business_deductions: parseFloat(stats.business_deductions) || 0,
      mileage_deductions: parseFloat(stats.mileage_deductions) || 0,
      expense_count: parseInt(stats.expense_count, 10) || 0,
      mileage_count: parseInt(stats.mileage_count, 10) || 0,
      total_miles: parseFloat(stats.total_miles) || 0,
      expenses_by_category: expensesByCategory,
      monthly_breakdown: monthlyResult.rows.map(row => ({
        month: row.month,
        amount: parseFloat(row.amount) || 0,
      })),
    };
  }

  /**
   * Get all expense categories
   */
  async getCategories(): Promise<Array<{
    category_id: string;
    category_name: string;
    category_code: string;
    irs_line_number: string | null;
    deduction_rate: number;
    description: string | null;
  }>> {
    const result = await query(
      `SELECT category_id, category_name, category_code, irs_line_number, deduction_rate, description
       FROM expense_categories
       WHERE is_active = TRUE
       ORDER BY sort_order, category_name`
    );

    return result.rows.map(row => ({
      category_id: row.category_id,
      category_name: row.category_name,
      category_code: row.category_code,
      irs_line_number: row.irs_line_number,
      deduction_rate: parseFloat(row.deduction_rate) || 100,
      description: row.description,
    }));
  }

  /**
   * Map database row to ManualExpenseWithCategory object
   */
  private mapToExpenseWithCategory(row: Record<string, unknown>): ManualExpenseWithCategory {
    return {
      manual_expense_id: row.manual_expense_id as string,
      user_id: row.user_id as string,
      expense_date: new Date(row.expense_date as string),
      merchant: row.merchant as string,
      amount: parseFloat(row.amount as string),
      category_id: row.category_id as string | null,
      category_name: row.category_name as string,
      is_business: row.is_business as boolean,
      business_percentage: parseFloat(row.business_percentage as string) || 100,
      notes: row.notes as string | null,
      payment_method: row.payment_method as string | null,
      receipt_photo_url: row.receipt_photo_url as string | null,
      receipt_thumbnail_url: row.receipt_thumbnail_url as string | null,
      ocr_raw_text: row.ocr_raw_text as string | null,
      ocr_confidence: row.ocr_confidence ? parseFloat(row.ocr_confidence as string) : null,
      ocr_extracted_data: row.ocr_extracted_data as Record<string, unknown> | null,
      is_mileage: row.is_mileage as boolean,
      miles: row.miles ? parseFloat(row.miles as string) : null,
      mileage_rate: row.mileage_rate ? parseFloat(row.mileage_rate as string) : null,
      start_location: row.start_location as string | null,
      end_location: row.end_location as string | null,
      created_at: new Date(row.created_at as string),
      updated_at: new Date(row.updated_at as string),
      // Extended fields from join
      category_code: row.category_code as string | undefined,
      irs_line_number: row.irs_line_number as string | undefined,
      deduction_rate: row.deduction_rate ? parseFloat(row.deduction_rate as string) : undefined,
    };
  }
}

// Export singleton instance
export const expenseService = new ExpenseService();
